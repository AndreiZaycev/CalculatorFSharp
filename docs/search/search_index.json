{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CalculatorFSharp CalculatorFSharp is a library which mainly designed to compute arithmetic expressions. CalculatorFSharp contains an interpreter for the simple programming language, long arithmetic and non-empty list libraries. Installing You can install the package with dotnet by following this steps: Add a source in your NuGet.config file dotnet nuget add source \"https://nuget.pkg.github.com/AndreiZaycev/index.json\" Authorize with your github token paket config add-token \"https://nuget.pkg.github.com/AndreiZaycev/index.json\" <token> Install the package dotnet add PROJECT package CalculatorFSharp --version <version>","title":"Home"},{"location":"#calculatorfsharp","text":"CalculatorFSharp is a library which mainly designed to compute arithmetic expressions. CalculatorFSharp contains an interpreter for the simple programming language, long arithmetic and non-empty list libraries.","title":"CalculatorFSharp"},{"location":"#installing","text":"You can install the package with dotnet by following this steps: Add a source in your NuGet.config file","title":"Installing"},{"location":"#_1","text":"dotnet nuget add source \"https://nuget.pkg.github.com/AndreiZaycev/index.json\" Authorize with your github token","title":""},{"location":"#_2","text":"paket config add-token \"https://nuget.pkg.github.com/AndreiZaycev/index.json\" <token> Install the package","title":""},{"location":"#_3","text":"dotnet add PROJECT package CalculatorFSharp --version <version>","title":""},{"location":"BigAriphmetics/","text":"BigAriphmetics BigAriphmetic is an attempt to create long arithmetic on F#. Type An instanse of BigInt consists of signOfNumber of <Sign> and digits of <MyList<int>> . Sign type has only two values - Positive and Negative . MyList<int> consists of integers from 0 to 9. Methods BigInt convertStringToNegative (y: string) - returns negative BigInt BigInt.toString - converts BigInt to string Functions toInt (data: BigInt) - returns integer from BigInt initPosInt (x: MyList<int>) - creates absolute BigInt createBigInt (length: int) - creates BigInt by length addZeroEnd (x: MyList<int>) (k: int) - adds zeroes at end of BigInt compareNumbers (x: MyList<int>) (y: MyList<int>) - compares two numbers deleteZeroes (x: MyList<int>) - deletes insignificant zeroes from list equalizeLength (x: BigInt) (y: BigInt) - equalizes length of two numbers transferDigits (x: MyList<int>) - transfers remainders from position to next position sum (x:BigInt) (y:BigInt) - returns sum of two numbers sub (x:BigInt) (y:BigInt) - returns a result of subtraction of two numbers multiply (x:BigInt) (y:BigInt) - returns a result of multiplication of two numbers divAndRem (x:BigInt) (y:BigInt) - returns a pair of remainder and whole part of division in BigInt type division (x:BigInt) (y:BigInt) - returns a whole part of division remDiv (x:BigInt) (y:BigInt) - returns a remainder from division power (x:BigInt) (y:BigInt) - returns a result of exponentiation toBinary (x:BigInt) - converts a number to it's binary representation absolute (x:BigInt) - return an absolute value of a number","title":"BigAriphmetics"},{"location":"BigAriphmetics/#bigariphmetics","text":"BigAriphmetic is an attempt to create long arithmetic on F#.","title":"BigAriphmetics"},{"location":"BigAriphmetics/#type","text":"An instanse of BigInt consists of signOfNumber of <Sign> and digits of <MyList<int>> . Sign type has only two values - Positive and Negative . MyList<int> consists of integers from 0 to 9.","title":"Type"},{"location":"BigAriphmetics/#methods-bigint","text":"convertStringToNegative (y: string) - returns negative BigInt BigInt.toString - converts BigInt to string","title":"Methods BigInt"},{"location":"BigAriphmetics/#functions","text":"toInt (data: BigInt) - returns integer from BigInt initPosInt (x: MyList<int>) - creates absolute BigInt createBigInt (length: int) - creates BigInt by length addZeroEnd (x: MyList<int>) (k: int) - adds zeroes at end of BigInt compareNumbers (x: MyList<int>) (y: MyList<int>) - compares two numbers deleteZeroes (x: MyList<int>) - deletes insignificant zeroes from list equalizeLength (x: BigInt) (y: BigInt) - equalizes length of two numbers transferDigits (x: MyList<int>) - transfers remainders from position to next position sum (x:BigInt) (y:BigInt) - returns sum of two numbers sub (x:BigInt) (y:BigInt) - returns a result of subtraction of two numbers multiply (x:BigInt) (y:BigInt) - returns a result of multiplication of two numbers divAndRem (x:BigInt) (y:BigInt) - returns a pair of remainder and whole part of division in BigInt type division (x:BigInt) (y:BigInt) - returns a whole part of division remDiv (x:BigInt) (y:BigInt) - returns a remainder from division power (x:BigInt) (y:BigInt) - returns a result of exponentiation toBinary (x:BigInt) - converts a number to it's binary representation absolute (x:BigInt) - return an absolute value of a number","title":"Functions"},{"location":"Listik/","text":"Listik MyList is a non-empty list library which is used in a BigAriphmetics module. Type MyList is a discriminated union with One of 't or Cons of 't * MyList<t> . Functions head (x:MyList<'t>) - returns a head of a list tail (x:MyList<'t>) - reurns a tail of a list fold (f:'a -> 'b -> 'a) (acc:'a) (x:MyList<'b>) - changes a sign of a number length (x:MyList<'t>) - returns a length of a list concat (x:MyList<'t>) (y:MyList<'t>) - deletes all zeroes from the begining of a list map (f:'a -> 'b) (x:MyList<'a>) - returns a list to whose elements the given function has been applied iter (f:'a -> unit) (x:MyList<'a'>) - applies a given function to each element of a list sort (x:MyList<'t>) - returns a sorted list toMyList (x:List<'t>) - converts List to MyList generator (t: int) - generates MyList with length equal t toSystemList (x:MyList<'t>) - converts MyList to List rev (x:BigInt) - returns a list with elements in a reversed order intToMyList (i:int) - converts int to MyList indexElem (x: MyList<'t>) (i: int) - returns the elemnt on i position map2 (f: 'a -> 'b -> 'a) (x: MyList<'a>) (y: MyList<'b>) - //map2 (easter egg) returns two list to whose elements the given function has been applied","title":"Listik"},{"location":"Listik/#listik","text":"MyList is a non-empty list library which is used in a BigAriphmetics module.","title":"Listik"},{"location":"Listik/#type","text":"MyList is a discriminated union with One of 't or Cons of 't * MyList<t> .","title":"Type"},{"location":"Listik/#functions","text":"head (x:MyList<'t>) - returns a head of a list tail (x:MyList<'t>) - reurns a tail of a list fold (f:'a -> 'b -> 'a) (acc:'a) (x:MyList<'b>) - changes a sign of a number length (x:MyList<'t>) - returns a length of a list concat (x:MyList<'t>) (y:MyList<'t>) - deletes all zeroes from the begining of a list map (f:'a -> 'b) (x:MyList<'a>) - returns a list to whose elements the given function has been applied iter (f:'a -> unit) (x:MyList<'a'>) - applies a given function to each element of a list sort (x:MyList<'t>) - returns a sorted list toMyList (x:List<'t>) - converts List to MyList generator (t: int) - generates MyList with length equal t toSystemList (x:MyList<'t>) - converts MyList to List rev (x:BigInt) - returns a list with elements in a reversed order intToMyList (i:int) - converts int to MyList indexElem (x: MyList<'t>) (i: int) - returns the elemnt on i position map2 (f: 'a -> 'b -> 'a) (x: MyList<'a>) (y: MyList<'b>) - //map2 (easter egg) returns two list to whose elements the given function has been applied","title":"Functions"},{"location":"interpreter/","text":"Interpreter Interpreter can be used both for developers and users Developers To interpretate your code, at first you need to create an abstract sytax tree by using the following function Main.parse <string> Then you can run the Interpreter.run <ast> function that returns three dictionaries. The first contains values of all variables in Exp.Expression format,the second contains variables in string format, the third has only one key - \"print\" with string of result of interpretation. You can also get a dot file which contains a syntax tree by using DrawTree.drawTree <ast> <output file path> Another functions processExpr (vDict: Dictionary<AST.VName,AST.Expression>) (expr: Exp.Expression) - return a result of a given expression in BigInt format processStmt (vDict: Dictionary<AST.VName,AST.Expression>) (stmt: Exp.Stmt) (pDict: Dictionary<string,string>) - gets an expression from a statement and sets it's value to a dictionaries with variable as a key calculate (ast: Exp.Stmt list) - assisting function to compute a result of code with a single statement Example on F#: let x = \"x = 228 print x\" let ast = parse x let _, _, pDict = Interpreter.run ast printfn \"%s\" pDict.[\"print\"] Given code prints \"228\" into console Users There are only four console commands in CalculatorFSharp --inputfile <file path> - enter a file with code --inputstring <string> - enter a string with code --compute - return the result of interpretation of the code --todot <file path> - return dot code of syntax tree to the given file Just run \"CalculatorFSharp.exe\" from console with given commands","title":"Interpreter"},{"location":"interpreter/#interpreter","text":"Interpreter can be used both for developers and users","title":"Interpreter"},{"location":"interpreter/#developers","text":"To interpretate your code, at first you need to create an abstract sytax tree by using the following function Main.parse <string> Then you can run the Interpreter.run <ast> function that returns three dictionaries. The first contains values of all variables in Exp.Expression format,the second contains variables in string format, the third has only one key - \"print\" with string of result of interpretation. You can also get a dot file which contains a syntax tree by using DrawTree.drawTree <ast> <output file path>","title":"Developers"},{"location":"interpreter/#another-functions","text":"processExpr (vDict: Dictionary<AST.VName,AST.Expression>) (expr: Exp.Expression) - return a result of a given expression in BigInt format processStmt (vDict: Dictionary<AST.VName,AST.Expression>) (stmt: Exp.Stmt) (pDict: Dictionary<string,string>) - gets an expression from a statement and sets it's value to a dictionaries with variable as a key calculate (ast: Exp.Stmt list) - assisting function to compute a result of code with a single statement","title":"Another functions"},{"location":"interpreter/#example-on-f","text":"","title":"Example on F#:"},{"location":"interpreter/#_1","text":"let x = \"x = 228 print x\" let ast = parse x let _, _, pDict = Interpreter.run ast printfn \"%s\" pDict.[\"print\"] Given code prints \"228\" into console","title":""},{"location":"interpreter/#users","text":"There are only four console commands in CalculatorFSharp --inputfile <file path> - enter a file with code --inputstring <string> - enter a string with code --compute - return the result of interpretation of the code --todot <file path> - return dot code of syntax tree to the given file Just run \"CalculatorFSharp.exe\" from console with given commands","title":"Users"},{"location":"lang/","text":"Language guide Usage Each arithmetic expression is defined as variable which can be used in other expressions. Result of each expression can be printed in console Code consists of statements with expressions and variable's names associated with them. Each arithmetic expression is defined as variable which can be used in other expressions. Value of a variable can be printed in console There are only two statements supported in this language: var = expr # Variable declaration, var is name of variable which consists of 'a' - 'z', 'A' - 'Z' symbols, expr is number or expression print var # To print something you need use key \"print\" and specify variable you want to output Operations + - Sums two expressions - - Subtracts the second expression from the first expression -variable | -digit - Unary minus helps the calculator understand the sign of the variable or digit * - Multiplies two expressions / - Divides the first expression into the second expression ^ - Result of raising to the power of the first expression to the second expression { expr } - Brackets to absolute expression % - Remainder of dividing the first expression by the second expression # - Converts expression to binary system = - Binds a variable name to a value or expression ( expr ) - Brackets to set the order of operations Expressions Num of <BigInt> NVar of <VName> Sum of <Expression * Expression> Sub of <Expression * Expression> Mul of <Expression * Expression> Div of <Expression * Expression> Rem of <Expression * Expression> Pow of <Expression * Expression> DivRem of <Expression * Expression> Bin of <Expression> Abs of <Expression> Templates x = 5 x = x + 10 # x = 15 x = 5 y = 6 z = 5 x = (x + y) / z print x # output : 2 x = 12 + 6 / 3 - 7 print x # output : 7","title":"Language guide"},{"location":"lang/#language-guide","text":"","title":"Language guide"},{"location":"lang/#usage","text":"Each arithmetic expression is defined as variable which can be used in other expressions. Result of each expression can be printed in console Code consists of statements with expressions and variable's names associated with them. Each arithmetic expression is defined as variable which can be used in other expressions. Value of a variable can be printed in console There are only two statements supported in this language: var = expr # Variable declaration, var is name of variable which consists of 'a' - 'z', 'A' - 'Z' symbols, expr is number or expression print var # To print something you need use key \"print\" and specify variable you want to output","title":"Usage"},{"location":"lang/#operations","text":"+ - Sums two expressions - - Subtracts the second expression from the first expression -variable | -digit - Unary minus helps the calculator understand the sign of the variable or digit * - Multiplies two expressions / - Divides the first expression into the second expression ^ - Result of raising to the power of the first expression to the second expression { expr } - Brackets to absolute expression % - Remainder of dividing the first expression by the second expression # - Converts expression to binary system = - Binds a variable name to a value or expression ( expr ) - Brackets to set the order of operations","title":"Operations"},{"location":"lang/#expressions","text":"Num of <BigInt> NVar of <VName> Sum of <Expression * Expression> Sub of <Expression * Expression> Mul of <Expression * Expression> Div of <Expression * Expression> Rem of <Expression * Expression> Pow of <Expression * Expression> DivRem of <Expression * Expression> Bin of <Expression> Abs of <Expression>","title":"Expressions"},{"location":"lang/#templates","text":"x = 5 x = x + 10 # x = 15 x = 5 y = 6 z = 5 x = (x + y) / z print x # output : 2 x = 12 + 6 / 3 - 7 print x # output : 7","title":"Templates"}]}